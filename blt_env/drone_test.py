from typing import Dict, Optional, List, Tuple
import time
from logging import getLogger, NullHandler, StreamHandler, INFO, DEBUG

import numpy as np
import pybullet as p
import pybullet_data

from util.data_tools import DroneProperties, DroneType, DroneKinematicInfo, PhysicsType
from util.file_tools import get_drone_properties

logger = getLogger(__name__)
# logger.addHandler(NullHandler())
logger.setLevel(DEBUG)  # for standalone debugging
logger.addHandler(StreamHandler())  # for standalone debugging


class BulletSimTest(object):
    def __init__(
            self,
            urdf_path: str,
            d_type: DroneType = DroneType.QUAD_PLUS,
            sim_freq: int = 240,
            phy_mode: PhysicsType = PhysicsType.PYB,
    ):
        """
        Parameters
        ----------
        urdf_path : the drone .URDF file path.
        d_type : Specifies the type of drone to be loaded from the .URDF file.
        sim_freq : Specifies the frequency of the pybullet step simulations.
        """
        self._drone_type = d_type
        self._urdf_path = urdf_path
        self._physics_mode = phy_mode

        # load the drone properties form the .urdf file
        self._dp = get_drone_properties(self._urdf_path, self._drone_type)
        self.printout_drone_properties()

        # pybullet sim settings
        self._g = self._dp.g
        self._sim_freq = sim_freq
        self._sim_time_step = 1. / self._sim_freq

        # initialize the positions of the drones.
        self._init_xyz = np.array([0, 0, 0.5])
        self._init_rpy = np.zeros(3)

        # pybullet environment
        self._client = p.connect(p.GUI)
        p.setTimeStep(self._sim_time_step, physicsClientId=self._client)
        p.setGravity(0, 0, -self._g)

        # load objects
        p.setAdditionalSearchPath(pybullet_data.getDataPath())
        self._plane_id = p.loadURDF('plane.urdf')

        # load drone
        self._drone_id = p.loadURDF(
            fileName=self._urdf_path,
            basePosition=self._init_xyz,
            baseOrientation=p.getQuaternionFromEuler(self._init_rpy),
        )

        ''' 
        The 'DroneKinematicInfo' class is simply a placeholder for the following information.
            pos : position
            quat : quaternion
            rpy : roll, pitch and yaw
            vel : linear velocity
            ang_vel : angular velocity
            rpy_rate :  roll, pitch, and yaw rates
            rotor_rpm:  rpm of each rotor
        '''
        self._ki = DroneKinematicInfo()
        self.update_drones_kinematic_info(
            rpm_values=np.zeros(4),
        )  # Update the information before running the simulations.

    @property
    def sim_freq(self) -> int:
        return self._sim_freq

    @property
    def sim_time_step(self) -> float:
        return self._sim_time_step

    @property
    def drone_properties(self) -> DroneProperties:
        return self._dp

    @property
    def drones_kinematic_info(self) -> DroneKinematicInfo:
        return self._ki

    def close(self) -> None:
        p.disconnect(physicsClientId=self._client)

    def reset(self) -> None:
        self._ki = DroneKinematicInfo()

    def step(self, rpm_values: np.ndarray) -> DroneKinematicInfo:

        if self._physics_mode is PhysicsType.PYB:
            self.apply_rotor_physics(rpm_values)
        elif self._physics_mode is PhysicsType.DYN:
            self.apply_dynamics(rpm_values)

        # Do not use p.stepSimulation() for the explicit solution technique.
        if self._physics_mode != PhysicsType.DYN:
            p.stepSimulation(physicsClientId=self._client)

        self.update_drones_kinematic_info(rpm_values=rpm_values)
        return self._ki

    def apply_rotor_physics(self, rpm_values: np.ndarray):
        """
        Apply the individual thrusts and torques generated by the motion of the four rotors.
        4つのローターの動きによって発生する個々の推力とトルクを単純に適用。

        Parameters
        ----------
        rpm_values : A list with 4 elements.  Specify the 'rpm' for each of the four rotors.
        nth_drone : The ordinal number of the desired drone in list self._drone_ids.
        """
        assert len(rpm_values) == 4, f"The length of rpm_values must be 4. currently it is {len(rpm_values)}."
        forces = (np.array(rpm_values) ** 2) * self._dp.kf
        torques = (np.array(rpm_values) ** 2) * self._dp.km
        z_torque = (-torques[0] + torques[1] - torques[2] + torques[3])
        for i in range(4):
            p.applyExternalForce(
                objectUniqueId=self._drone_id,
                linkIndex=i,  # link id of the rotors.
                forceObj=[0, 0, forces[i]],
                posObj=[0, 0, 0],
                flags=p.LINK_FRAME,
                physicsClientId=self._client,
            )
        p.applyExternalTorque(
            objectUniqueId=self._drone_id,
            linkIndex=4,  # link id of the center of mass.
            torqueObj=[0, 0, z_torque],
            flags=p.LINK_FRAME,
            physicsClientId=self._client,
        )

    def apply_dynamics(self, rpm_values: np.ndarray):
        """
        Apply dynamics taking into account moment of inertia, etc.
        (Compute dynamics without using p.stepSimulation().)
        慣性モーメントなどを考慮した力学を陽解法を用いて適用

        This is a reference from the following ...

            https://github.com/utiasDSL/gym-pybullet-drones/blob/master/gym_pybullet_drones/envs/BaseAviary.py

            Based on code written at the Dynamic Systems Lab by James Xu.

        Parameters
        ----------
        rpm_values : A list with 4 elements.  Specify the 'rpm' for each of the four rotors.
        nth_drone : The ordinal number of the desired drone in list self._drone_ids.
        """
        assert len(rpm_values) == 4, f"The length of rpm_values must be 4. currently it is {len(rpm_values)}."

        # current state
        pos = self._ki.pos
        quat = self._ki.quat
        rpy = self._ki.rpy
        vel = self._ki.vel
        rpy_rates = self._ki.rpy_rates
        rotation = np.array(p.getMatrixFromQuaternion(quat)).reshape(3, 3)

        # compute thrust and torques
        thrust, x_torque, y_torque, z_torque = self.rpm2forces(rpm_values)
        thrust = np.array([0, 0, thrust])

        thrust_world_frame = np.dot(rotation, thrust)
        forces_world_frame = thrust_world_frame - np.array([0, 0, self._dp.gf])

        torques = np.array([x_torque, y_torque, z_torque])
        torques = torques - np.cross(rpy_rates, np.dot(self._dp.J, rpy_rates))
        rpy_rates_deriv = np.dot(self._dp.J_inv, torques)
        no_pybullet_dyn_accs = forces_world_frame / self._dp.m

        # update state
        vel = vel + self._sim_time_step * no_pybullet_dyn_accs
        rpy_rates = rpy_rates + self._sim_time_step * rpy_rates_deriv
        pos = pos + self._sim_time_step * vel
        rpy = rpy + self._sim_time_step * rpy_rates

        # Set PyBullet state
        p.resetBasePositionAndOrientation(
            bodyUniqueId=self._drone_id,
            posObj=pos,
            ornObj=p.getQuaternionFromEuler(rpy),
            physicsClientId=self._client,
        )

        # Note: the base's velocity only stored and not used
        p.resetBaseVelocity(
            objectUniqueId=self._drone_id,
            linearVelocity=vel,
            angularVelocity=[-1, -1, -1],  # ang_vel not computed by DYN
            physicsClientId=self._client,
        )

        # Store the roll, pitch, yaw rates for the next step
        self._ki.rpy_rates = rpy_rates

    def rpm2forces(self, rpm_values: np.ndarray) -> Tuple:
        """
        Compute thrust and x, y, z axis torque at specified rotor speed.

        Parameters
        ----------
        rpm_values : A list with 4 elements.  Specify the 'rpm' for each of the four rotors.

        Returns
        -------
        (
            thrust,  # It is sum of the thrust of the 4 rotors.
            x_torque,  # It is the torque generated by the thrust of the rotors.
            y_torque,  # It is the torque generated by the thrust of the rotors.
            z_torque,  #  It is sum of the torque of the 4 rotors.
        )
        """
        forces = np.array(rpm_values) ** 2 * self._dp.kf
        thrust = np.sum(forces)
        z_torques = np.array(rpm_values) ** 2 * self._dp.km
        z_torque = (-z_torques[0] + z_torques[1] - z_torques[2] + z_torques[3])
        if self._drone_type == DroneType.QUAD_X:
            x_torque = (forces[0] + forces[1] - forces[2] - forces[3]) * (self._dp.l / np.sqrt(2))
            y_torque = (- forces[0] + forces[1] + forces[2] - forces[3]) * (self._dp.l / np.sqrt(2))
        elif self._drone_type in [DroneType.QUAD_PLUS, DroneType.OTHER]:
            x_torque = (forces[1] - forces[3]) * self._dp.l
            y_torque = (-forces[0] + forces[2]) * self._dp.l
        return thrust, x_torque, y_torque, z_torque

    def update_drones_kinematic_info(self, rpm_values: np.ndarray):
        self._ki.rotor_rpm = rpm_values
        self._ki.pos, self._ki.quat = p.getBasePositionAndOrientation(
            bodyUniqueId=self._drone_id,
            physicsClientId=self._client,
        )
        self._ki.rpy = p.getEulerFromQuaternion(self._ki.quat)
        self._ki.vel, self._ki.ang_vel = p.getBaseVelocity(
            bodyUniqueId=self._drone_id,
            physicsClientId=self._client,
        )

    def printout_drone_properties(self) -> None:
        mes = f"""
        {self.__class__.__name__} loaded parameters from the .urdf :
        {self._urdf_path}
        m: {self._dp.m}
        l: {self._dp.l}
        ixx: {self._dp.ixx}
        iyy: {self._dp.iyy}
        izz: {self._dp.izz}
        kf: {self._dp.kf}
        km: {self._dp.km}
        J: {self._dp.J}
        thrust2weight_ratio: {self._dp.thrust2weight_ratio}
        max_speed_kmh: {self._dp.max_speed_kmh}
        gnd_eff_coeff: {self._dp.gnd_eff_coeff}
        prop_radius: {self._dp.prop_radius}
        drag_coeff_xy: {self._dp.drag_coeff_xy}
        drag_z_coeff: {self._dp.drag_coeff_z}
        dw_coeff_1: {self._dp.dw_coeff_1}
        dw_coeff_2: {self._dp.dw_coeff_2}
        dw_coeff_3: {self._dp.dw_coeff_3}
        gf: {self._dp.gf}
        hover_rpm: {self._dp.hover_rpm}
        max_rpm: {self._dp.max_rpm}
        max_thrust: {self._dp.max_thrust}
        max_xy_torque: {self._dp.max_xy_torque}
        max_z_torque: {self._dp.max_z_torque}
        grand_eff_h_clip: {self._dp.grand_eff_h_clip}
        grand_eff_h_clip: {self._dp.grand_eff_h_clip}
        A: {self._dp.A}
        B_coeff: {self._dp.B_coeff}
        Mixer: {self._dp.Mixer}
        """
        logger.info(mes)


if __name__ == "__main__":
    '''
    If you want to run this module by itself, try the following.

       $ python -m blt_env.simple_env

    '''

    urdf_file = 'assets/drone_p_01.urdf'
    drone_type = DroneType.QUAD_PLUS
    # phy_mode = PhysicsType.PYB
    phy_mode = PhysicsType.DYN

    env = BulletSimTest(
        urdf_path=urdf_file,
        d_type=drone_type,
        gui=True,
        phy_mode=phy_mode,
    )

    env.printout_drone_properties()

    # blt_env = DroneDynamicsEnv(
    #     urdf_path=urdf_file,
    #     d_type=drone_type,
    #     gui=True,
    # )

    rpms = np.array([14300, 14300, 14300, 14300])

    step_num = 300
    for _ in range(step_num):
        _ = env.step(rpms)
        time.sleep(env.sim_time_step)

    env.close()
